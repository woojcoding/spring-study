# 스프링 핵심원리
<details>
<summary> 객체 지향 설계와 스프링</summary>
<div markdown="1">

## 1.스프링 이란?
### 스프링 프레임워크
- 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 :트랜잭션, JDBC, ORM, XML
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 최근 스프링 부트를 통해 기술들을 편리하게 사용  

### 스프링 부트  
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 웹 서버 내장
- starter 종속성 제공으로 손쉬운 빌드 구성
- 외부 라이브러리 자동 구성
- 간결한 설정
- 프로덕션 준비 기능 제공

### 스프링?
- 스프링 DI 컨테이너 기술
- 스프링 프레임 워크
- 스프링부트, 스프링 프레임워크를 모두 포함한 스프링 생태계

### 스프링의 핵심 개념
- 웹 애플리케이션을 만들고 DB 접근 편리, 전자정부 프레임워크, 웹 서버 자동, 클라우드 마이크로 서비스?? -> 이는 그냥 결과물일 뿐이다.

- 스프링은 객체지향 언어인 자바 언어 기반 프레임워크로 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와준다.


## 2.  좋은 객체 지향 프로그래밍이란?
### 좋은 객체 지향 프로그래밍
- 각각의 객체는 메시지를 주고 받고 데이터를 처리할 수 있다. (협력)
- 객체지향 프로그래밍을 프로그램을 유연하고 변경이 용이하게 만들어 대규모 소프트웨어 개발에 많이 사용된다. (다형성)  
-> 역할과 구현의 구분
  -인터페이스에 의존하도록 구현한다면 구현체가 바뀌더라도 영향을 끼치지 않는다.
- 자바언어의 다형성을 활용
- 역할(인터페이스) / 구현(구현 객체)
- 객체 설계 시 역할과 구현을 명확히 분리
- 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 구현 객체 만들기

### 객체의 협력 관계
- 혼자있는 객체는 없다
- 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

### 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체간 관계에서 시작한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

### 역할과 구현 분리
- 실세계의 역할과 구현이라는 컨셉을 다형성을 통해 객체 세상에 반영가능
- 유연하며 변경이 용이, 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경이 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요  
–> 인터페이스 자체가 변하면 클라이언트와 서버 모두에 큰 변경이 발생한다.

### 스프링과 객체 지향
- 다형성이 가장 중요하다
- 스프링은 다형성을 극대화하여 이용하도록 도와준다.
- IoC(제어의 역전), DI(의존성 주입) : 다형성을 활용해 역할과 구현을 편리하게 다루도록 지원해주는 것
- 스프링을 사용하면 구현을 편리하게 변경할 수 있다.


## 3. 좋은 객체 지향 설계의 5가지 원칙(SOLID)
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open/Closed Principle): 개방-폐쇄 원칙
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존관계 역전 원칙

### SRP(Single Responsibility Principle): 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호한데 클 수도 , 작을 수도 있으며 상황에 따라 다르다.
- 중요한 기준은 변경이다.  
-> 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.

### OCP(Open/Closed Principle): 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 다형성을 활용해야 한다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 역할과 구현의 분리를 생각해보나 문제점이 있다.
- 구현 객체를 변경하려면 클라이언트 코드를 변경해햐한다.
- 다형성을 사용했으나 OCP 원칙을 지킬 수 없다.  
-> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

### LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- 프로그램 객체는 정확성을 깨뜨리지 않으며 하위 타입의 인스턴스로 바꿀 수 있어야한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.
- EX) 자동차 인터페이스에서 엑셀은 앞으로 가는 기능이다. 만약 뒤로 이동하게 구현한다면 LSP 위반이다. -> 이는 단순히 컴파일에 성공하는 것을 넘어서는 이야기이다.


### ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리  
-> 분리를 통해 정비 인터페이스가 변하여도 운전자 클라이언트에 영향을 끼치지 않게된다.  
-> 인터페이스가 명확해지며, 대체 가능성이 높아진다.

### DIP(Dependency Inversion Principle): 의존관계 역전 원칙
- 추상화에 의존하며, 구체화에 의존하면 안된다.
- 즉 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다는 뜻
- 역할에 의존하게 해야 한다는 것과 같다.  
-> 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.

```MemberRepository m = new MemoryMemberRepository();```
- MemberService 클라이언트가 직접 구현 클래스를 선택하게 되면 인터페이스에 의존하지만, 구현 클래스도 동시에 의존하게 된다 -> DIP 위반

### 정리
- 객체 지향의 핵심은 다형성
- 다형성만으로는 쉽게 개발할 수 없다.
- 다형상만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성만으로는 OCP, DIP를 지킬 수 없다.  
-> 더 필요하다

## 4. 객체 지향 설계와 스프링
- 스프링은 DI, DI 컨테이너를 통해 다형성 + OCP, DIP를 가능하게 지원
- 클라이언트 코드의 변경 없이 기능 확장
- 쉽게 부품을 교체하듯 개발 가능해짐  
-> 순수 자바로 OCP, DIP원칙들을 지키며 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다.

### 정리
- 모든 설계에 역할과 구현을 분리하자.
- 역할만 만들어 두고 유연하게 구현체를 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.  
-> BUT 인터페이스를 도입하려면 추상화라는 비용이 발생하기에 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링으로 인터페이스를 도입하는 것도 방법이다.
</div>
</details>

<details>
<summary>예제 - 도메인 설계</summary>
<div markdown="1">

## 1. 회원 도메인
- 회원 가입 및 조회 가능
- 회원 등급 - 일반, VIP
- 회원 데이터는 아직 미확정으로 자체 DB 구축 OR 외부 시스템과 연동
## 2. 주문 및 할인 도메인
- 회원은 상품 주문 가능
- 회원 등급에 따른 할인 정책 적용
- VIP 등급은 1000원 고정 할인 적용 (변경 가능)
- 할인 정책 -> 변경가능성 매우 높으며 아직 미확정

## 미확정인 부분들이 많으나 객체 지향 설계 방법을 통하여 인터페이스를 만들고 구현체를 대체하는 방법으로 설계하면 된다.
- 회원 저장소를 인터페이스로 설계 후 memory / db / 외부시스템 회원저장소를 구현 후 구현체를 교체하면 된다.
- 할인 정책의 경우 인터페이스로 설계 후 fix / rate 로 구현 후 구현체를 교체하면 된다.
</div>
</details>

<details>
<summary> 객체 지향 원리 적용</summary>
<div markdown="1">

## 새로운 할인 정책 개발
- 정액 할인 -> 정률 할인으로 변경
- 역할과 구현을 분리하여 인터페이스와 구현 객체를 분리했다.
- OrderServiceImpl 에서 추상뿐만 아니라 구현 클래스에도 의존 -> DIP 위반
- 구현체를 바꾸기 위해 클라이언트 코드도 바꿔야함 -> OCP 위반  
-> 인터페이스에만 의존하도록 코드를 변경 해준다.  
-> 구현 객체를 대신 생성하고 주입을 해주어야한다.

### 관심사의 분리
- 인터페이스 변수를 선언만 하며 구현체를 지정까지 직접 하지 말자.
- final로 인터페이스 변수만 선언 해주고 생성자를 만들어준다.
- 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스를 만들어서 해결한다.
- AppConfig 라는 클래스를 만들어 인스턴스를 생성자 주입 해준다.   
-> 이제 인터페이스에만 의존하며 생성자를 통해 어떤 구현 객체가 들어올지는 외부에서만 결정된다.  
-   의존관계에 대한 고민은 외부에 맡기며 실행에만 집중할 수 있게 되었다.  
-> DIP가 완성되었으며 AppConfig 가 레포지토리 구현체를 생성하고 서비스 구현체를 생성 후 생성자 주입해준다.  
-> 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리됐다.(관심사 분리)

### IoC, DI, 컨테이너
제어의 역전 IoC(Inversion of Control)
- 구현 객체는 자신의 로직을 실행하는 역할만 담당하고 프로그램의 제어 흐름은 AppConfig가 가져간다.
- 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라 한다.  

의존관계 주입 DI(Dependency Injection)
- 의존관계는 정적인 클래스 의존관계와 실행시점에 결정되는 동적인 객체 의존관계를 불리해서 생각해야 한다.
  

- 정적 클래스 의존관계 : 클래스 내부에 import 코드를 통해 의존관계를 쉽게 판단할 수 있다. 
  

- 동적인 객체 인스턴스 의존관계 : 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계.
    

-  애플리케이션 실행시점에 외부에서 실제 구현 객체를 생성 후 클라이언트에 전달해 클라이언트와 서버의 신제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
- 객체 인스턴스를 생성 후 참조값을 전달하여 연결된다.
- 의존관계 주입 시 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

IoC 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성, 관리, 의존관계를 연결해 주는 것
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
</div>
</details>

<details>
<summary> 스프링 컨테이너와 스프링 빈 </summary>
<div markdown="1">

### 스프링 컨테이너
- ApplicationContext : 스프링 컨테이너
- 기존에는 개발자가 AppConfig를 사용하여 객체를 생성하고 DI를 하였지만 이제부터는 스프링 컨테이너를 ㅅ용한다.
- 스프링 컨테이너는 @Configuration 애너테이션이 붙은 AppConfig를 설정 정보로 사용하며 @Bean 이 적힌 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 스프링 빈으로 등록한다.,
- 스프링 빈은 @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.
- 이전에는 AppConfig를 이용하여 객체를 조회하였으나, 이제부터는 applicationContext.getBean()을 통해 객체를 찾는다.
- 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아 사용한다.

### 스프링 컨테이너 생성 과정
1. 스프링 컨테이너 생성
```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```
- ApplicationContext는 인터페이스로 스프링 컨테이너이다.
- 위 코드는 애너테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것으로 AnnotationConfigApplicationContext 는 인터페이스의 구현체이다.
- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다.
2. 스프링 빈 등록
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용하여 스프링 빈을 등록한다. 
- key : value
- 빈이름(메서드명) : 빈 객체(메서드를 통해 반환된 객체)
- 빈 이름은 메서드 명을 사용
- 빈 이름은 직접 부여 가능`@Bean(name="beanName111")`
- 빈 이름은 항상 다른 이름을 부여해야 한다. - 같은 이름 부여 시 오류 발생
3. 스프링 빈 의존관계 설정
- 스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나누어져 있다.
- 스프링 컨테이너가 설정 정보를 참고하여 DI 한다.
  
정리
- 스프링 컨테이너를 생성할 때, 구성 정보를 참고하여 스프링 빈을 등록하고 의존관계 설정을 하였다.

### 스프링 컨테이너에 등록된 빈 조회
- `ac.getBeanDefinitionNames()` : 스프링에 등록된 모든 빈 이름 조회
- `ac.getBean()` : 빈 이름을 파라미터로 빈 객체를 조회한다.
- `ac.getBeanDefinition.getRole()` : ROLE_APPLICATION 사용자가 정의한 빈 / ROLE_INFRASTRUCTURE 스프링 내부에서 사용하는 빈

### 스프링 컨테이너에 등록된 빈 조회 - 기본
-`ac.getBean(빈이름, 타입)`
- `ac.getBean(타입)`
- -> 스프링 빈이 없을 경우 `NoSuchBeanDefinitionException: No Bean Named xxx available` 예외 발생

### 스프링 컨테이너에 등록된 빈 조회 - 동일한 타입이 둘 이상
- 타입만으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생하기에 빈 이름과 타입을 지정하여 조회해야한다.
- `ac.getBeansOfType()`을 통해 해당 타입의 모든 빈을 Map<String, 빈타입> 으로 조회 가능하다.

### 스프링 컨테이너에 등록된 빈 조회 - 상속관계
- 부모 타입으로 조회하면, 자식 타입도 함꼐 조회된다.
- 가장 상위 타입인 Object로 조회시, 모든 스프링 빈 조회 가능하다.

### BeanFactory / ApplicationContext
BeanFactory (인터페이스) <- ApplicationContext (인터페이스) <- AnnotationConfigApplicationContext  

BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할 담당
- `getBean()` 을 제공

ApplicationContext
- BeanFactory 기능을 모두 상속 받아 제공
- 애플리케이션을 개발할 때에는 빈을 관리, 조회하는 기능은 물론이고, 수 많은 부가기능들이 필요하다.  
  
  - ApplicationContext가 제공하는 부가기능
  - "메세지소스를 활용한 국제화 기능" - 한국에선 한국어, 영어권에선 영어로 출력
  - "환경변수" - 로컬, 개발, 운영 등을 구분해서 처리할 수 있게 해준다.
  - "애플리케이션 이벤트" - 이벤트를 발행하고 구독하는 모델을 편리하게 지원해준다.
  - "편리한 리소스 조회" - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회하게 해준다.
정리
  - ApplicationContext는 BeanFactory의 기능을 상속받는다.
  - ApplicationContext : 빈 관리 + 편리한 부가기능 제공
  - BeanFactory 보다는 부가기능이 포함된 ApplicationContext를 사용한다.
  - BeanFactory, ApplicationContext를 스프링 컨테이너라고 한다.

### 다양한 설정 형식 지원 - 자바코드, XML
- 스프링 컨테이너는 다양한 형식의 설정을 받아들일 수 있으며 유연하게 설계되어 있다.
  - Java, XML, Groovy 등


애너테이션 기반 자바 코드 설정
- `new AnnotatoinConfigApplicationContext(AppConfig.class)` 를 통해 자바 코드로 된 설정 정보를 넘기면 된다.

XML 설정 사용
- 최근에는 스프링 부트를 사용하기에 잘 사용되지 않는다.
- 레거시 프로젝트들이 XML로 되어 있으며 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점이 있다.
- `GenericXmlApplicationContext`를 사용하여 xml 설정 파일을 넘기면 된다.

### 스프링 빈 설정 메타 정보 - BeanDefinition
- 스프링은 BeanDefinition 이라는 추상화 인터페이스를 통하여 다양한 설정 형식을 지원한다.
- 스프링 컨테이너는 BeanDefinition에 의존한다.
- XML, 자바 코드를 읽어 BeanDefinition을 만든다.
- BeanDefinition은 빈 설정 메타정보라 한다.
- @Bean , `<bean>` 당 각각 하나씩 메타 정보가 생성된다.
- 스프링컨테이너는 이 메타 정보를 기반으로 스프링 빈을 생성한다.
- `AnnotationConfigApplicationContext` 가 `AnnotatedBeanDefinitionReader` 를 통해 `AppConfig.class`를 읽어 `BeanDefinition`을 생성한다.
- `GenericXmlApplicationContext`는 `XmlBeanDefinitionReader`를 사용해 `appConfig.xml` 를 읽어 `BeanDefinition` 을 생성한다.
  
BeanDefinition 정보
- BeanClassName : 생성할 빈의 클래스 명(자바 설정의 경우 팩토리 역할의 빈을 사용하기에 없음)
- factoryBeanName : 팩토리 역할의 빈을 사용할 경우 이름 ex) appConfig
- factoryMethodName : 빈을 생성할 팩토리 메서드 지정 ex) memberService
- Scope : 싱글톤(default)
- lazyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아닌, 실제 빈을 사용할 때 까지 생성을 지연처리 하는지의 여부
- initMethodName: 빈 생성 후, 의존관계를 적용한 뒤 호출되는 초기화 메서드 명
- DestroyMethodNameL 빈의 생명 주기가 끝나 제거하기 직전에 호출되는 메서드 명

정리
- BeanDefinition을 직접 생성하여 스프링 컨테이너에 등록할 수 있으나 실무에서는 직접 정의하거나 사용할 일 거의 없다.
- 스프링은 다양한 형태의 설정 정보를 BeanDefinition으로 추상화하여 사용할 수 있다.
- XML은 직접 스프링 빈을 등록하는 방식
- 자바 설정 클래스는 팩토리 메서드를 통해 등록하는 방식
</div>
</details>

<details>
<summary> 싱글톤 컨테이너 </summary>
<div markdown="1">

## 웹 애플리케이션과 싱글톤
- 스프링은 기업용 온라인 서비스 기술을 지원하기 위한 프레임워크
- 대부분의 스프링 애플리케이션은 웹 애플리케이션이다.
- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
- 스프링 없는 순수 DI 컨테이너의 경우 고객이 요청을 할 때마다 새로운 객체를 생성하여 반환하게 된다. -> 메모리 낭비가 심하다.
- 해결방안은 해당 객체가 1개만 생성되고 공유되도록 설계하면 된다. = 싱글톤 패턴

## 싱글톤 패턴
- 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴
- private 생성자를 사용하여 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야한다.
- 호출할 때 마다 같은 객체 인스턴스를 반환하는 것을 확인할 수 있다.
- 고객의 요청이 올 떄 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유하여 효율적으로 사용할 수 있다.
### 싱글톤 패턴의 문제점
- 싱글톤 패턴을 구현하는 코드 자체가 많아진다. -> static으로 생성해두고, getInstance()도 만들고 private으로 생성자도 막아줘야함.
- 의존관계상 클라이언트가 구체 클래스에 의존한다. -> getInstance()로 꺼내와야 하기에 DIP를 위반한다.
- 클라이언트가 구체 클래스에 의존하여 OCP 원칙을 위반할 가능성이 높다.
- 테스트 하기 어렵다.
- 내부속성을 변경하거나 초기화 하기 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 유연성이 떨어져 안티패턴으로 불리기도 한다.
## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하며, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
- 싱글톤 레지스트리 : 싱글톤 객체를 생성하고 관리하는 기능
- 스프링 컨테이너의 이런 기능 덕에 싱글톤 패턴의 모든 단점을 해결하며 객체를 싱글톤으로 유지 가능하다.
## 싱글톤 방식의 문제점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성하여 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문제 싱글톤 객체는 상태를 stateful(유지)하게 설계 하면 안된다.
- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 큰 장애가 발생할 수 있다.
- 스프링 빈은 항상 무상태로 설계하자

## @Configuration과 싱글톤
- memberService 빈을 만들 떄 memberRepository() 호출
- orderService 빈을 만들 때 memberRepository() 호출
- memberRepository 빈을 만들 때 memberRepository() 호출
- 이 처럼 memberRepository()를 3번 호출하며 싱글톤이 깨질 것 같아 보이나 실제로는 각 빈들의 메서드를 한번씩만 호출된다.  
  
  
-> 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.
- @Configuration 애너테이션을 달아둔 경우 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용하여 Appconfig 클래스를 상속받은 AppConfig@CGLIB라는 다른 클래스를 만들고 이 다른 클래스를 스프링 빈으로 등록한다.
- 이미 객체가 스프링 컨테이너에 등록되어 있다면 스프링 컨테이너에서 찾아서 반환해주고
- 스프링 컨테이너에 없다면 기존 로직을 호출하여 객체를 생성하고 스프링 컨테이너에 등록하여
- 싱글톤을 보장해준다.
  
@Configuration을 적용하지 않고 @Bean만 적용한다면?
- CGLIB기술이 적용되지 않은 순수한 AppConfig가 스프링 빈에 등록된다.
- memberRepository()를 3번 호출하여 싱글톤 패턴이 깨진다.

스프링 설정 정보는 항상 `@Configuration` 을 사용해야 한다.
</div>
</details>

<details>
<summary> 컴포넌트 스캔</summary>
<div markdown="1">

## 컴포넌트 스캔과 의존관계 자동 주입하기
- 기존에는 @Bean, xml의 경우 `<bean>` 등을 통해 직접 스프링 빈을 등록하였다.
- 스프링은 설정 정보가 없이 자동으로 스프링 빈을 등록하는 컴포넌트 스캔 기능을 제공한다.
- 의존관계의 경우 @AutoWired 를 통해 자동 주입 가능하다.
  

- `@Configuration, @ComponentScan` 을 설정 정보에 붙여준다.
- 기존 설정파일을 컴포넌트 스캔의 대상에서 제외하기 위해 excludeFilters 를 이용하여 Configuration 애너테이션이 붙은 클래스는 제외하였다.
- 각 클래스가 컴포넌트 스캔 대상이 되도록 `@Component` 애너테이션을 붙여준다.
- 의존관계를 설정해 주기 위해 생성자 위에 `@Autowired` 애너테이션을 붙여 생성자 주입을 해준다.

컴포넌트 스캔과 자동 의존관계 주입 과정
1. @ComponentScan
- @ComponentScan은 @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다.
- 빈이름과 빈 객체를 등록하는데 기존 클래스명의 맨 앞글자만 소문자로 변경하여 저장한다.
- MemberServiceImpl 클래스는 memberServiceImpl 로 저장된다.
- @Component("스프링빈 이름 직접지정") 으로 빈 이름 직접 지정이 가능하다.
2. @Autowired
- 생성자에 @Autowired를 지정시 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 기본 조회 전력은 타입이 같은 빈을 찾아서 주입한다.
- `ac.getBean(MemberRepository.class)` 와 동일
- 생성자에 파라미터가 많아도 전부 자동으로 주입한다.

## 탐색 위치와 기본 스캔 대상

탐색할 패키지의 시작 위치 지정
- 모든 자바 클래스를 스캔하면 시간이 오래 걸리기에 특정 위치부터 탐색하도록 지정할 수 있다.
- `@ComponentScan(basePackages = "woojcoding.springcore`
- `basePackages` : 탐색할 패키지의 시작 위치를 지정, 이 패키지를 포함한 하위 패키지를 탐색
- {"woojcoding.a","woojcoding,b"} 로 여러 시작 위치 지정 가능
- `basePackageClasses` : 해당 클래스의 패키지를 탐색 시작 위치로 지정
- Default : @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작위치
- 설정 정보 클래스의 위치를 프로젝트 최상단에 둔다. -> 해당 패키지의 하위 모두 자동으로 컴포넌트 스캔의 대상이 된다.

컴포넌트 스캔 기본 대상
- `@Component` : 컴포넌트 스캔에 사용
- `@Controller` : 스프링 MVC 컨트롤러로 인식
- `@Service` : 핵심 비즈니스 로직이 있다고 인식하는데 도움을 줌
- `@Repository` : 스프링 데이터 접근 계층으로 인식하여 데이터 계층 예외를 스프링 예외로 변환
- `@Configuration` : 스프링 설정 정보로 인식하며 스프링 빈이 싱글톤을 유지하도록 추가 처리함
- 애너테이션에 특정 애너테이션이 있다는 것을 인식하는 것은 스프링의 지원 기능이다.

## 필터
- `includeFilters` : 컴포넌트 스캔 대상을 추가 지정
- `excludeFilters` : 컴포넌트 스캔에서 대상 제외

필터타입 옵션
- ANNOTATION : 기본값, 애너테이션을 인식
- ASSIGNABLE_TYPE : 지정 타입과 자식 타입 인식
- ASPECTJ : AspectJ 패턴
- REGEX : 정규 표현식
- CUSTOM : TypeFilter 인터페이스 구현하여 처리

## 중복 등록과 충돌

자동 빈 등록, 자동 빈 등록
- 컴포넌트 스캔으로 자동 빈 등록과정에서 ConflictingBeanDefinitionException 발생

수동 빈 등록, 자동 빈 등록
- 수동 빈이 자동 빈을 오버라이딩 해버린다.

원치 않은 빈으로 등록되어 버그가 만들어질 수 있다.  
스프링 부트의 경우 수동 빈 등록, 자동 빈 등록이 충돌이 나 오류가 발생하도록 기본값이 설정 되어 있다. 
</div>
</details>
<details>
<summary> 의존관계 자동 주입</summary>
<div markdown="1">

## 다양한 의존관계 주입 방법
의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.

- 생성자 주입
- 수정자 주입
- 필드 주입
- 일반 메서드 주입

### 생성자 주입
```java
private final MemberRepository memberRepository;

@Autowired
public memberServiceImpl(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
        }
```
- 생성자를 통해 의존관계를 주입하는 방법
- 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
- 불변(Setter 만들지 않아 데이터 수정X), 필수(final 필드) 의존관계에 사용
- <u> 생성자가 딱 1개만 있다면 @Autowired를 생략하여도 자동 주입 된다.</u>

### 수정자 주입(Setter 주입)
```java
private MemberRepository memberRepository;

@Autowired
public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
        }
```
- setter(수정자) 메서드를 통해 의존관계를 주입하는 방법
- 선택(required = false로 없어도 구동 되게끔), 변경(중간에 instance를 바꿀 때) 가능성이 있는 의존관계에 사용
- 자바빈 프로퍼티 규악의 수정자 메서드 방식을 사용하는 방법(getter, setter를 이용하여 데이터를 조회, 수정하는 방식)
- `@Autowired(required = false)`: 주입할 대상이 없어도 동작하게 된다.

### 필드 주입
```java
@Autowired
private MemberRepository memberRepository;
```
- 필드에 바로 주입하는 방법
- 외부에서 변경이 불가능해 테스트를 하기 위해서는 결국 setter를 따로 만들어 주입을 해줘야 한다 -> 테스트를 하기 어렵다.
- DI 프레임워크가 없으면 아무것도 할 수가 없어 사용하지 말자.
- 테스트코드나 @Configuration 같은 곳에서만 특수한 용도로 사용한다.

### 일반 메서드 주입
```java
private MemberRepository memberRepository;

@Autowired
public void init(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
        }
```
- 일반 메서드를 통해 주입하는 방법
- 한번에 여러 필드를 주입할 수 있다.
- 일반적으로 잘 사용X

## 필드 주입 옵션 처리
주입할 빈이 없으면 기본 알고리즘으로 동작하는 방식으로 구현할 때 수정자 주입에 옵션을 처리하여 사용한다.
- @Autowired의 required 옵션의 경우 true가 default 값이다. -> 자동 주입 대상이 없다면 오류가 발생한다.
- @Autowired(required = false) : 자동 주입할 대상이 없다면 메서드 자체가 호출이 안된다.
- @Nullable 파라미터 : 자동 주입할 대상이 없다면 null이 입력된다.
- Optional<> 파라미터 : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

## 생성자 주입을 사용하기!
생성자 주입을 권장하는 이유?

### 불변
- 대부분의 의존관계 주입의 경우 애플리케이션 종료시점까지 의존관계를 변경할 일이 없으며 오히려 대부분의 의존관계는 불변해야 한다.
- 수정자 주입을 사용한다면 setter메서드를 public으로 열어두어야 한다 -> 실수로 변경 가능, 변경하면 안되는 메서드를 열어두는 것은 좋지 않은 설계 방법
- 생성자 주입의 경우 객체 생성시 단 1번만 호출되고 이후에는 호출이 되지 않아 불변하게 설계가 가능하다.
### 누락
- 수정자 주입을 사용시 테스트코드를 작성하는 과정에서 의존관계를 설정해주지 않는다면 NPE가 발생하게 된다.
- 생성자 주입을 사용하면 주입을 하지 않는다면 컴파일 오류가 발생하여 직관적으로 파악할 수 있다.
### final
- 생성자 주입 사용시에는 필드에 final 키워드를 사용할 수 있는데 이 때문에 값이 설정되지 않는 경우에는 컴파일 에러를 볼 수 있다.
- 생성자 주입을 제외한 다른 주입들은 생성자 이후에 호출 되기에 필드에 final 키워드 사용이 불가능하다.
- 오직 생성자 주입만 final 키워드를 사용 가능하다.

### 정리
- 생성자 주입 : 순수 자바 언어의 특징을 잘 살리는 방법
- 기본으로는 생성자 주입, 필수 값이 아닌 경우 수정자 주입 방식을 사용하며 옵션처리를 해준다.
- 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
- 생성자 주입을 선택하되 옵션이 필요한 경우에만 수정자 주입 방식 사용하기

## 조회 빈이 2개 이상일 경우 문제점
- @Autowired는 타입으로 조회한다(ac.getBean() 과 유사)
- 하위타입 2가지를 스프링 빈으로 선언해둔 후 부모타입을 의존관계 자동주입한다면
- `NoUniqueBeanDefinitionException` 오류 발생 : 스프링 빈이 1개일 것이라 예상하였으나 두개나 등록되어 있기 때문이다.
- 의존관계 주입을 부모타입 -> 하위타입으로 변경한다면 DIP위반, 유연성이 떨어진다.

해결방법
### 필드명
- @Autowired는 타입을 조회 후 여러 빈이 있다면 필드이름과 파라미터 이름으로 빈 이름을 찾는다.
```java
변경 전
@Autowired
private DiscountPolicy discountPolicy;

변경 후
@Autowired
private DiscountPolicy rateDiscountPolicy;
```
- 생성자 주입시 파라미터 명을 rateDiscountPolicy로 변경해도 된다.

@Autowired 매칭
- 1. 타입 매칭
- 2. 타입 매칭 결과가 2개 이상인 경우 필드명, 파라미터 명으로 빈 이름 매칭
### @Qualifier
- 추가 별명을 붙여준느 방법으로 빈 이름을 변경하는 것은 아니다

1. @Qualifier를 붙여 빈을 등록해준다.
```java
@Component
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {}
```
2. 생성자나 수정자 주입시 @Qualifier("별명") 을 적어준다.
```java
@Autowired
public OrderServiceImpl(@Qualifier("mainDiscountPolicy") DiscountPolicy
discountPolicy) {
 this.discountPolicy = discountPolicy;
}
```
`@Qualifier`
- @Qualifier를 매칭
- 해당 별명을 가진 Qualifer가 없다는 해당 별명을 이름으로 가진 스프링 빈을 찾는다.
- 그래도 없다면 NoSuchBeanDefinitionException 오류 발생
### @Primary
- @Primary로 우선순위를 부여한다.
- 여러 빈이 매칭된다면 @Primary가 우선권을 가진다.
```java
@Component
@Primary
public class RateDiscountPolicy implements DiscountPolicy {}
```

정리
- 자주 사용하는 스프링 빈은 @Primary를 적용한다.
- 가끔 사용하는 스프링 빈은 @Qualifier를 지정하여 생성자 주입시 @Qualifier를 지정하여 주입해준다.
- 우선순위 @Primary < @Qualifier

### 애너테이션을 만들어 사용하기
- @Qualifier("오타발생가능") -> 문자를 적게 되므로 생성자 주입을 하거나 할 떄 오타가 발생하더라도 컴파일시 타입 체크가 안된다.
- @Qualifier에 붙어있는 애너테이션들을 복사해온 후 @Qualifier("별명") 을 통해 애너테이션을 만들어 사용한다면 해당 문제를 해결할 수 있다.

## 조회한 빈이 모두 필요한 경우 -> List, Map을 활용
- 조회한 빈이 모두 필요한 경우 스프링을 사용하여 전략 패턴을 간단하게 구현가능하다.
- Map 또는 List로 모든 스프링 빈을 주입 받는다.
- Map의 경우 스프링빈의 이름, 객체 로 담아진다.
- 상황에 따라 원하는 스프링 빈을 컬렉션에서 꺼내어 실행한다.

## 실무에서 자동, 수동
- 자동 기능을 기본으로 사용
- 스프링 부트의 경우 컴포넌트 스캔이 기본값이다.
- 컨트롤러, 서비스, 레포지토리 와 같은 업무 로직 빈의 경우 자동등록한다.
- 광범위하게 영향을 미치는 기술 지원 빈의 경우 수동 빈 등록을 하여 명확하게 하는 것이 좋다.
- 다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해봐야 한다. -> 자동으로 한다면 특정 패키지에 같이 묶어 두는게 좋다.
</div>
</details>

<details>
<summary> 빈 생명주기 콜백</summary>
<div markdown="1">

## 빈 생명주기 콜백
- 애플리케이션 시작 시점에 필요한 연결은 미리 해두고 종료 시점에 연결을 모두 종료하는 작업을 진행하려면 객체의 초기화와 종료 작업이 필요하다.
- 스프링은 의존관계 주입이 완료 후 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공한다.
- 또한 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다.  

### 스프링 빈의 이벤트 라이프 사이클
1. 스프링 컨테이너 생성
2. 스프링 빈 생성 (생성자 주입은 의존관계 주입도 같이 일어난다.)
3. 의존관계 주입 (필드주입, 수정자 주입)
4. 초기화 콜백
5. 스프링 빈이 사용됨
6. 소멸전 콜백
7. 스프링 종료

### 스프링의 빈 생명 주기 콜백
-  인터페이스(InitializingBean, DisposableBean)
- 설정 정보에 초기화, 종료 메서드 지정
- @PostConstruct, @PreDestroy 애너테이션

## 인터페이스 InitializingBean, DisposableBean
- InitializingBean 을 상속 받아 afterPropertiesSet()을 오버라이드한다.
- afterPropertiesSet()은 초기화를 지원해준다.
- DisposableBean 을 상속 받아 destroy()을 오버라이드한다.
- destroy()는 소멸을 지원한다.
- 의존관계가 주입 완료 된 후 초기화 메서드가 호출되고 스프링 컨테이너 종료가 호출되면 소멸 메서드가 호출된다.
- 단점
  - 스프링 전용 인터페이스로 코드가 스프링에 의존하게 된다.
  - 초기화, 소멸 메서드의 이름 변경이 불가능하다.
  - 코드 변경이 불가능한 외부 라이브러리에 적용이 불가능하다.

## 설정 정보에 초기화, 소멸 메서드 지정
- `@Bean(initMethod = "초기화 메서드명", destroyMethod = "소멸 메서드명")`을 통해 옵션을 부여하기만 하면 된다.
- 이 경우 인터페이스 방식과는 다르게 메서드 이름 변경이 가능하며
- 스프링 빈이 스프링 코드에 의존하지 않게 된다.
- 외부라이브러리도 빈으로 등록 후 초기화, 종료 메서드를 적용할 수 있다.
- destroyMethod 옵션은 추론 기능이 있어 지정을 하지 않아도 close, shutdown 이름의 메서드를 자동으로 호출한다.

## @PostConstruct, @PreDestroy
- 메서드 위에 해당 애너테이션을 써주기만 하면 된다.
- 스프링에서 가장 권장하는 방법으로 자바 표준 기술이기에 스프링이 아닌 다른 컨테이너에서도 동작한다.
- 컴포넌트 스캔에서도 사용 가능하다.
- 외부 라이브러리에는 적용이 불가하기에 @Bean 옵션 기능을 사용해야 한다

## 정리
- @PostConstruct, @PreDestroy를 초기화, 소멸 메서드 위에 달아주자.
- 코드 수정이 불가한 외부라이브러리의 경우 @Bean(initMethod, destroyMethod) 를 통해 초기화, 소멸 메서드를 지정해주자.
</div>
</details>
<details>
<summary> 빈 스코프</summary>
<div markdown="1">

## 빈 스코프란?
- 싱글톤 : 기본 스코프로 스프링 컨테이너 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
- 프로토타입 : 스프링 컨테이너는 프로토 타입 빈의 생성과 의존관계 주입 후 초기화 메서드를 호출까지만 관여하고 더 이상 관리하지 않는 매우 짧은 범위의 스코프
- 웹 관련
  - request : 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
  - session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
  - application: 서블릿 컨텍스트와 같은 범위로 유지되는 스코프
-`@Scope("prototype")`를 @Component 나 @Bean 애너테이션 위에 달아 지정할 수 있다.

## 프로토 타입 스코프
- 싱글톤 빈 조회시 컨테이너에 등록된 스프링 빈을 반환하지만
- 프로토타입 빈 조회를 요청 받는다면 스프링 컨테이너가 프로토타입 빈을 생성하고 의존관계 주입, 초기화까지만 처리한다. 항상 새로운 인스턴스를 반환하게 되는 것이다. 소멸메서드는 호출되지 않는다.
- 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행
- 프로토타입 스코프 빈은 스프링 컨테이너에서 빈을 조회할 때 생성되고 초기화 메서드가 실행
- 프로토타입 빈은 종료메서드가 호출되지 않기에 조회한 클라이언트가 직접 해야한다.

## 프로토타입 스코프 - 싱글톤 빈과 함꼐 사용시 문제점
프로토타입 빈을 요청하여 초기 필드값 0에서 1로 증가하는 로직을 호출시 
- 프로토타입 빈은 요청마다 새로 생성되기에 서로 다른 객체이므로 각 빈의 필드값이 1이 될 것이다.

이 프로토 타입 빈을 싱글톤 빈에 의존관계 주입을 하는 경우
- 싱글톤 빈을 컨테이너 생성 시점에 함께 생성하고 의존관계 주입이 진행된다.
- 싱글톤 빈에 존재하는 프로토타입 빈의 메서드를 호출하여 프로토타입 빈의 필드값을 1증가 시킨다면
- 이미 프로토타입 빈이 주입되어 있기에 프로토타입 빈이 새로 생성되지 않고 기존에 만들어진 빈의 메서드를 호출하기에 1씩 계속 증가하게 될 것이다. -> 싱글톤 빈 생성 시점에 의존관계 주입을 받기 때문에 프로토타입 빈이 새로 생성되기는 하지만 싱글톤 빈과 함께 계속 유지되는 문제가 발생하였다.
- 프로토타입을 쓰는 이유는 프로토타입 빈을 주입 시점에만 새로 생성하는 것이 아닌, 사용할 때  마다 새로 생성해서 사용하길 원하는 것이다.

## 프로토타입 스코프 - 해결 방법

### 스프링 컨테이너에 요청
- 가장 간단한 방법으로 싱글톤 빈의 필드에 프로토타입 빈을 주입하는 것이 아니라 스프링컨테이너를 주입받는다.
- 로직을 호출시 스프링컨테이너에서 프로토타입 빈을 꺼낸다면 항상 새로운 인스턴스를 반환해 줄 것이다.
- 이런식으로 DI를 하는 것이 아닌 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL) 이라 한다.
- 스프링 컨테이너를 주입한다면 스프링 컨테이너에 종속적인 코드가 되어 단위테스트가 어려워진다.
- DL 정도의 기능을 제공하는 것이 스프링에 준비되어있다.

### ObjectFactory, ObjectProvider 인터페이스
- DL 서비스를 제공한다.
- ObjectProvider를 상속받아 편의기능을 추가한 것이 ObjectProvider이다.
- ObjectProvider의 getObject()  호출시 스프링 컨테이너를 통해 해당 빈을 찾아 반환한다.(DL) -> 프로토타입 빈은 새로 생성되어 반환된다.
- ObjectFactory: 기능 단순, 별도 라이브러리 필요X, 스프링에 의존
- ObjectProvider: ObjectFactory 상속, 옵션과 스트림 처리 등 편의 기능이 많음, 별도 라이브러리 필요X, 스프링에 의존

### JSR-330 Provider 인터페이스
`javax.inject:javax.inject:1` 라이브러리를 추가하여 자바 표준을 사용하는 방법
- provider.get()을 호출시 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(DL)
- 기능이 단순하고 테스트 만들기가 쉬워진다.
- DL 정도의 기능만 제공한다.
- 자바 표준이므로 스프링이 아닌 컨테이너에서도 사용가능하며 별도의 라이브러리가 필요하다.

### 정리
- 프로토타입 빈은 언제 사용? 사용할 때 마다 매번 의존관계 주입이 완료된 새로운 객체가 필요할 때
- 실무에서 프로토타입 빈을 사용하는 일은 매우 드물다.
- ObjectProvider, JSR330 Provider 를 통해 DL 기능을 사용할 수 있다.
- 스프링이 아닌 다른 컨테이너에서 사용해야 한다면 JSR330 Provider 사용하자.
- 특별히 다른 컨테이너를 사용하지 않는다면 스프링이 제공하는 기능이 더 다양하고 편리하기에 스프링 기술을 사용하자.

## 웹 스코프
- 웹 환경에서만 동작
- 프로토타입이 초기화까지만 진행되는 것과 다르게 해당 스코프의 종료시점까지 스프링이 관리하므로 종료 메서드가 호출된다.
- request : HTTP 요청이 들어와서 응답이 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 빈이 생성되고 관리된다.
- session : HTTP 세션과 동일한 생명주기를 가지는 스코프
- application: 서블릿 컨텍스트와 동일한 생명주기를 가지는 스코프
- websocket: 웹소켓과 동일한 생명주기를 가지는 스코프

### request 스코프 예제
- 웹스코프가 웹환경에서 동작하기에 `spring-boot-starter-web` 라이브러리를 추가하였다.
- 내장 톰캣을 통해 서버와 스프링이 함께 실행된다.
- 로그를 기록하는 request 스코프 빈에 대한 로직, 초기화 메서드, 소멸 메서드를 지정해주었다.
- 컨트롤러에 로거 request 스코프 빈을 생성자 주입 해주었다.
- 컨트롤러에서 request 스코프 빈의 변수에 정보를 저장하여 서비스 계층에는 웹과 불필요한 정보를 넘기지 않았다. -> 웹과 관련된 부분은 컨트롤러에서만 사용하며 서비스 계층은 웹 기술에 종속되지 않고 순수하게 유지하는 것이 유지보수 관점에서 좋다.  

문제 발생
  - request 스코프 빈을 생성자 주입을 하려하니 오류가 발생하였다.
  - 스프링 컨테이너가 생성되고 빈을 등록하는 과정에서 컨트롤러 빈을 생성한다.
  - 의존관계 주입을 하는 과정에서 request 스코프 빈을 생성 후 주입해주는 상황이 문제를 야기했다.
  - request 스코프 빈은 HTTP 요청 당 새롭게 생성되어야 하므로
  - 컨트롤러 빈 의존관계 주입 과정에서는 생성될 수 없기 때문에 오류가 발생했다.  

해결 - Provider
  - ObjectProvider를 주입을 통해 request 스코프 빈의 생성을 지연할 수 있다.
  - ObjectProvider를 의존관계 주입 해주고 HTTP 요청이 왔을 때 getObject()을 호출한다면 스프링 컨테어너에 빈이 없기에 새로운 빈을 생성하여 반환해준다.
  - 컨트롤러와 서비스 계층에서 호출하더라도 같은 HTTP 요청이라면 같은 스프링 빈이 반환된다.
    
</div>
</details>
