# 스프링 핵심원리
<details>
<summary> 객체 지향 설계와 스프링</summary>
<div markdown="1">

## 1.스프링 이란?
### 스프링 프레임워크
- 핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 :트랜잭션, JDBC, ORM, XML
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 최근 스프링 부트를 통해 기술들을 편리하게 사용  

### 스프링 부트  
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 웹 서버 내장
- starter 종속성 제공으로 손쉬운 빌드 구성
- 외부 라이브러리 자동 구성
- 간결한 설정
- 프로덕션 준비 기능 제공

### 스프링?
- 스프링 DI 컨테이너 기술
- 스프링 프레임 워크
- 스프링부트, 스프링 프레임워크를 모두 포함한 스프링 생태계

### 스프링의 핵심 개념
- 웹 애플리케이션을 만들고 DB 접근 편리, 전자정부 프레임워크, 웹 서버 자동, 클라우드 마이크로 서비스?? -> 이는 그냥 결과물일 뿐이다.

- 스프링은 객체지향 언어인 자바 언어 기반 프레임워크로 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와준다.


## 2.  좋은 객체 지향 프로그래밍이란?
### 좋은 객체 지향 프로그래밍
- 각각의 객체는 메시지를 주고 받고 데이터를 처리할 수 있다. (협력)
- 객체지향 프로그래밍을 프로그램을 유연하고 변경이 용이하게 만들어 대규모 소프트웨어 개발에 많이 사용된다. (다형성)  
-> 역할과 구현의 구분
  -인터페이스에 의존하도록 구현한다면 구현체가 바뀌더라도 영향을 끼치지 않는다.
- 자바언어의 다형성을 활용
- 역할(인터페이스) / 구현(구현 객체)
- 객체 설계 시 역할과 구현을 명확히 분리
- 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 구현 객체 만들기

### 객체의 협력 관계
- 혼자있는 객체는 없다
- 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

### 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체간 관계에서 시작한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

### 역할과 구현 분리
- 실세계의 역할과 구현이라는 컨셉을 다형성을 통해 객체 세상에 반영가능
- 유연하며 변경이 용이, 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경이 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요  
–> 인터페이스 자체가 변하면 클라이언트와 서버 모두에 큰 변경이 발생한다.

### 스프링과 객체 지향
- 다형성이 가장 중요하다
- 스프링은 다형성을 극대화하여 이용하도록 도와준다.
- IoC(제어의 역전), DI(의존성 주입) : 다형성을 활용해 역할과 구현을 편리하게 다루도록 지원해주는 것
- 스프링을 사용하면 구현을 편리하게 변경할 수 있다.


## 3. 좋은 객체 지향 설계의 5가지 원칙(SOLID)
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open/Closed Principle): 개방-폐쇄 원칙
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존관계 역전 원칙

### SRP(Single Responsibility Principle): 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호한데 클 수도 , 작을 수도 있으며 상황에 따라 다르다.
- 중요한 기준은 변경이다.  
-> 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.

### OCP(Open/Closed Principle): 개방-폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 다형성을 활용해야 한다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 역할과 구현의 분리를 생각해보나 문제점이 있다.
- 구현 객체를 변경하려면 클라이언트 코드를 변경해햐한다.
- 다형성을 사용했으나 OCP 원칙을 지킬 수 없다.  
-> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

### LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- 프로그램 객체는 정확성을 깨뜨리지 않으며 하위 타입의 인스턴스로 바꿀 수 있어야한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.
- EX) 자동차 인터페이스에서 엑셀은 앞으로 가는 기능이다. 만약 뒤로 이동하게 구현한다면 LSP 위반이다. -> 이는 단순히 컴파일에 성공하는 것을 넘어서는 이야기이다.


### ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
- 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리  
-> 분리를 통해 정비 인터페이스가 변하여도 운전자 클라이언트에 영향을 끼치지 않게된다.  
-> 인터페이스가 명확해지며, 대체 가능성이 높아진다.

### DIP(Dependency Inversion Principle): 의존관계 역전 원칙
- 추상화에 의존하며, 구체화에 의존하면 안된다.
- 즉 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다는 뜻
- 역할에 의존하게 해야 한다는 것과 같다.  
-> 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.

```MemberRepository m = new MemoryMemberRepository();```
- MemberService 클라이언트가 직접 구현 클래스를 선택하게 되면 인터페이스에 의존하지만, 구현 클래스도 동시에 의존하게 된다 -> DIP 위반

### 정리
- 객체 지향의 핵심은 다형성
- 다형성만으로는 쉽게 개발할 수 없다.
- 다형상만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성만으로는 OCP, DIP를 지킬 수 없다.  
-> 더 필요하다

## 4. 객체 지향 설계와 스프링
- 스프링은 DI, DI 컨테이너를 통해 다형성 + OCP, DIP를 가능하게 지원
- 클라이언트 코드의 변경 없이 기능 확장
- 쉽게 부품을 교체하듯 개발 가능해짐  
-> 순수 자바로 OCP, DIP원칙들을 지키며 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다.

### 정리
- 모든 설계에 역할과 구현을 분리하자.
- 역할만 만들어 두고 유연하게 구현체를 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계이다.
- 이상적으로는 모든 설계에 인터페이스를 부여하자.  
-> BUT 인터페이스를 도입하려면 추상화라는 비용이 발생하기에 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링으로 인터페이스를 도입하는 것도 방법이다.
</div>
</details>

<details>
<summary>예제 - 도메인 설계</summary>
<div markdown="1">

## 1. 회원 도메인
- 회원 가입 및 조회 가능
- 회원 등급 - 일반, VIP
- 회원 데이터는 아직 미확정으로 자체 DB 구축 OR 외부 시스템과 연동
## 2. 주문 및 할인 도메인
- 회원은 상품 주문 가능
- 회원 등급에 따른 할인 정책 적용
- VIP 등급은 1000원 고정 할인 적용 (변경 가능)
- 할인 정책 -> 변경가능성 매우 높으며 아직 미확정

## 미확정인 부분들이 많으나 객체 지향 설계 방법을 통하여 인터페이스를 만들고 구현체를 대체하는 방법으로 설계하면 된다.
- 회원 저장소를 인터페이스로 설계 후 memory / db / 외부시스템 회원저장소를 구현 후 구현체를 교체하면 된다.
- 할인 정책의 경우 인터페이스로 설계 후 fix / rate 로 구현 후 구현체를 교체하면 된다.
</div>
</details>

<details>
<summary> 객체 지향 원리 적용</summary>
<div markdown="1">

## 새로운 할인 정책 개발
- 정액 할인 -> 정률 할인으로 변경
- 역할과 구현을 분리하여 인터페이스와 구현 객체를 분리했다.
- OrderServiceImpl 에서 추상뿐만 아니라 구현 클래스에도 의존 -> DIP 위반
- 구현체를 바꾸기 위해 클라이언트 코드도 바꿔야함 -> OCP 위반  
-> 인터페이스에만 의존하도록 코드를 변경 해준다.  
-> 구현 객체를 대신 생성하고 주입을 해주어야한다.

### 관심사의 분리
- 인터페이스 변수를 선언만 하며 구현체를 지정까지 직접 하지 말자.
- final로 인터페이스 변수만 선언 해주고 생성자를 만들어준다.
- 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스를 만들어서 해결한다.
- AppConfig 라는 클래스를 만들어 인스턴스를 생성자 주입 해준다.   
-> 이제 인터페이스에만 의존하며 생성자를 통해 어떤 구현 객체가 들어올지는 외부에서만 결정된다.  
-   의존관계에 대한 고민은 외부에 맡기며 실행에만 집중할 수 있게 되었다.  
-> DIP가 완성되었으며 AppConfig 가 레포지토리 구현체를 생성하고 서비스 구현체를 생성 후 생성자 주입해준다.  
-> 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리됐다.(관심사 분리)

### IoC, DI, 컨테이너
제어의 역전 IoC(Inversion of Control)
- 구현 객체는 자신의 로직을 실행하는 역할만 담당하고 프로그램의 제어 흐름은 AppConfig가 가져간다.
- 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라 한다.  

의존관계 주입 DI(Dependency Injection)
- 의존관계는 정적인 클래스 의존관계와 실행시점에 결정되는 동적인 객체 의존관계를 불리해서 생각해야 한다.
  

- 정적 클래스 의존관계 : 클래스 내부에 import 코드를 통해 의존관계를 쉽게 판단할 수 있다. 
  

- 동적인 객체 인스턴스 의존관계 : 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존관계.
    

-  애플리케이션 실행시점에 외부에서 실제 구현 객체를 생성 후 클라이언트에 전달해 클라이언트와 서버의 신제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
- 객체 인스턴스를 생성 후 참조값을 전달하여 연결된다.
- 의존관계 주입 시 클라이언트 코드를 변경하지 않고 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
- 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

IoC 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성, 관리, 의존관계를 연결해 주는 것
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
</div>
</details>

<details>
<summary> 스프링 컨테이너와 스프링 빈 </summary>
<div markdown="1">

### 스프링 컨테이너
- ApplicationContext : 스프링 컨테이너
- 기존에는 개발자가 AppConfig를 사용하여 객체를 생성하고 DI를 하였지만 이제부터는 스프링 컨테이너를 ㅅ용한다.
- 스프링 컨테이너는 @Configuration 애너테이션이 붙은 AppConfig를 설정 정보로 사용하며 @Bean 이 적힌 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 스프링 빈으로 등록한다.,
- 스프링 빈은 @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다.
- 이전에는 AppConfig를 이용하여 객체를 조회하였으나, 이제부터는 applicationContext.getBean()을 통해 객체를 찾는다.
- 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아 사용한다.

### 스프링 컨테이너 생성 과정
1. 스프링 컨테이너 생성
```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```
- ApplicationContext는 인터페이스로 스프링 컨테이너이다.
- 위 코드는 애너테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것으로 AnnotationConfigApplicationContext 는 인터페이스의 구현체이다.
- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다.
2. 스프링 빈 등록
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용하여 스프링 빈을 등록한다. 
- key : value
- 빈이름(메서드명) : 빈 객체(메서드를 통해 반환된 객체)
- 빈 이름은 메서드 명을 사용
- 빈 이름은 직접 부여 가능`@Bean(name="beanName111")`
- 빈 이름은 항상 다른 이름을 부여해야 한다. - 같은 이름 부여 시 오류 발생
3. 스프링 빈 의존관계 설정
- 스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나누어져 있다.
- 스프링 컨테이너가 설정 정보를 참고하여 DI 한다.
  
정리
- 스프링 컨테이너를 생성할 때, 구성 정보를 참고하여 스프링 빈을 등록하고 의존관계 설정을 하였다.

### 스프링 컨테이너에 등록된 빈 조회
- `ac.getBeanDefinitionNames()` : 스프링에 등록된 모든 빈 이름 조회
- `ac.getBean()` : 빈 이름을 파라미터로 빈 객체를 조회한다.
- `ac.getBeanDefinition.getRole()` : ROLE_APPLICATION 사용자가 정의한 빈 / ROLE_INFRASTRUCTURE 스프링 내부에서 사용하는 빈

### 스프링 컨테이너에 등록된 빈 조회 - 기본
-`ac.getBean(빈이름, 타입)`
- `ac.getBean(타입)`
- -> 스프링 빈이 없을 경우 `NoSuchBeanDefinitionException: No Bean Named xxx available` 예외 발생

### 스프링 컨테이너에 등록된 빈 조회 - 동일한 타입이 둘 이상
- 타입만으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생하기에 빈 이름과 타입을 지정하여 조회해야한다.
- `ac.getBeansOfType()`을 통해 해당 타입의 모든 빈을 Map<String, 빈타입> 으로 조회 가능하다.

### 스프링 컨테이너에 등록된 빈 조회 - 상속관계
- 부모 타입으로 조회하면, 자식 타입도 함꼐 조회된다.
- 가장 상위 타입인 Object로 조회시, 모든 스프링 빈 조회 가능하다.

### BeanFactory / ApplicationContext
BeanFactory (인터페이스) <- ApplicationContext (인터페이스) <- AnnotationConfigApplicationContext  

BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할 담당
- `getBean()` 을 제공

ApplicationContext
- BeanFactory 기능을 모두 상속 받아 제공
- 애플리케이션을 개발할 때에는 빈을 관리, 조회하는 기능은 물론이고, 수 많은 부가기능들이 필요하다.  
  
  - ApplicationContext가 제공하는 부가기능
  - "메세지소스를 활용한 국제화 기능" - 한국에선 한국어, 영어권에선 영어로 출력
  - "환경변수" - 로컬, 개발, 운영 등을 구분해서 처리할 수 있게 해준다.
  - "애플리케이션 이벤트" - 이벤트를 발행하고 구독하는 모델을 편리하게 지원해준다.
  - "편리한 리소스 조회" - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회하게 해준다.
정리
  - ApplicationContext는 BeanFactory의 기능을 상속받는다.
  - ApplicationContext : 빈 관리 + 편리한 부가기능 제공
  - BeanFactory 보다는 부가기능이 포함된 ApplicationContext를 사용한다.
  - BeanFactory, ApplicationContext를 스프링 컨테이너라고 한다.

### 다양한 설정 형식 지원 - 자바코드, XML
- 스프링 컨테이너는 다양한 형식의 설정을 받아들일 수 있으며 유연하게 설계되어 있다.
  - Java, XML, Groovy 등


애너테이션 기반 자바 코드 설정
- `new AnnotatoinConfigApplicationContext(AppConfig.class)` 를 통해 자바 코드로 된 설정 정보를 넘기면 된다.

XML 설정 사용
- 최근에는 스프링 부트를 사용하기에 잘 사용되지 않는다.
- 레거시 프로젝트들이 XML로 되어 있으며 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점이 있다.
- `GenericXmlApplicationContext`를 사용하여 xml 설정 파일을 넘기면 된다.

### 스프링 빈 설정 메타 정보 - BeanDefinition
- 스프링은 BeanDefinition 이라는 추상화 인터페이스를 통하여 다양한 설정 형식을 지원한다.
- 스프링 컨테이너는 BeanDefinition에 의존한다.
- XML, 자바 코드를 읽어 BeanDefinition을 만든다.
- BeanDefinition은 빈 설정 메타정보라 한다.
- @Bean , <bean> 당 각각 하나씩 메타 정보가 생성된다.
- 스프링컨테이너는 이 메타 정보를 기반으로 스프링 빈을 생성한다.
- `AnnotationConfigApplicationContext` 가 `AnnotatedBeanDefinitionReader` 를 통해 `AppConfig.class`를 읽어 `BeanDefinition`을 생성한다.
- `GenericXmlApplicationContext`는 `XmlBeanDefinitionReader`를 사용해 `appConfig.xml` 를 읽어 `BeanDefinition` 을 생성한다.
  
BeanDefinition 정보
- BeanClassName : 생성할 빈의 클래스 명(자바 설정의 경우 팩토리 역할의 빈을 사용하기에 없음)
- factoryBeanName : 팩토리 역할의 빈을 사용할 경우 이름 ex) appConfig
- factoryMethodName : 빈을 생성할 팩토리 메서드 지정 ex) memberService
- Scope : 싱글톤(default)
- lazyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아닌, 실제 빈을 사용할 때 까지 생성을 지연처리 하는지의 여부
- initMethodName: 빈 생성 후, 의존관계를 적용한 뒤 호출되는 초기화 메서드 명
- DestroyMethodNameL 빈의 생명 주기가 끝나 제거하기 직전에 호출되는 메서드 명

정리
- BeanDefinition을 직접 생성하여 스프링 컨테이너에 등록할 수 있으나 실무에서는 직접 정의하거나 사용할 일 거의 없다.
- 스프링은 다양한 형태의 설정 정보를 BeanDefinition으로 추상화하여 사용할 수 있다.
- XML은 직접 스프링 빈을 등록하는 방식
- 자바 설정 클래스는 팩토리 메서드를 통해 등록하는 방식
</div>
</details>

<details>
<summary> 싱글톤 컨테이너 </summary>
<div markdown="1">

## 웹 애플리케이션과 싱글톤
- 스프링은 기업용 온라인 서비스 기술을 지원하기 위한 프레임워크
- 대부분의 스프링 애플리케이션은 웹 애플리케이션이다.
- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
- 스프링 없는 순수 DI 컨테이너의 경우 고객이 요청을 할 때마다 새로운 객체를 생성하여 반환하게 된다. -> 메모리 낭비가 심하다.
- 해결방안은 해당 객체가 1개만 생성되고 공유되도록 설계하면 된다. = 싱글톤 패턴

## 싱글톤 패턴
- 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴
- private 생성자를 사용하여 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야한다.
- 호출할 때 마다 같은 객체 인스턴스를 반환하는 것을 확인할 수 있다.
- 고객의 요청이 올 떄 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유하여 효율적으로 사용할 수 있다.
### 싱글톤 패턴의 문제점
- 싱글톤 패턴을 구현하는 코드 자체가 많아진다. -> static으로 생성해두고, getInstance()도 만들고 private으로 생성자도 막아줘야함.
- 의존관계상 클라이언트가 구체 클래스에 의존한다. -> getInstance()로 꺼내와야 하기에 DIP를 위반한다.
- 클라이언트가 구체 클래스에 의존하여 OCP 원칙을 위반할 가능성이 높다.
- 테스트 하기 어렵다.
- 내부속성을 변경하거나 초기화 하기 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 유연성이 떨어져 안티패턴으로 불리기도 한다.
## 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하며, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
- 싱글톤 레지스트리 : 싱글톤 객체를 생성하고 관리하는 기능
- 스프링 컨테이너의 이런 기능 덕에 싱글톤 패턴의 모든 단점을 해결하며 객체를 싱글톤으로 유지 가능하다.
## 싱글톤 방식의 문제점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성하여 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문제 싱글톤 객체는 상태를 stateful(유지)하게 설계 하면 안된다.
- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 큰 장애가 발생할 수 있다.
- 스프링 빈은 항상 무상태로 설계하자

## @Configuration과 싱글톤
- memberService 빈을 만들 떄 memberRepository() 호출
- orderService 빈을 만들 때 memberRepository() 호출
- memberRepository 빈을 만들 때 memberRepository() 호출
- 이 처럼 memberRepository()를 3번 호출하며 싱글톤이 깨질 것 같아 보이나 실제로는 각 빈들의 메서드를 한번씩만 호출된다.  
  
  
-> 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.
- @Configuration 애너테이션을 달아둔 경우 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용하여 Appconfig 클래스를 상속받은 AppConfig@CGLIB라는 다른 클래스를 만들고 이 다른 클래스를 스프링 빈으로 등록한다.
- 이미 객체가 스프링 컨테이너에 등록되어 있다면 스프링 컨테이너에서 찾아서 반환해주고
- 스프링 컨테이너에 없다면 기존 로직을 호출하여 객체를 생성하고 스프링 컨테이너에 등록하여
- 싱글톤을 보장해준다.
  
@Configuration을 적용하지 않고 @Bean만 적용한다면?
- CGLIB기술이 적용되지 않은 순수한 AppConfig가 스프링 빈에 등록된다.
- memberRepository()를 3번 호출하여 싱글톤 패턴이 깨진다.

스프링 설정 정보는 항상 `@Configuration` 을 사용해야 한다.
</div>
</details>
